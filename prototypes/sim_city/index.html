<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Saigon Street Sprint</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Grotesk:wght@400;600;700&display=swap');

    :root {
      --ink: #0a0f14;
      --road: #1b232c;
      --lane: rgba(255, 230, 184, 0.7);
      --edge: rgba(255, 213, 120, 0.5);
      --accent: #f65a4b;
      --accent-2: #f1b84c;
      --mint: #6fe2c8;
      --sky-1: #f8b18a;
      --sky-2: #9dd7ff;
      --glow: rgba(255, 184, 120, 0.3);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at 10% 10%, #ffe5d0, #a0d9ff 45%, #5671b6 100%);
      color: #f6f1ea;
      font-family: "Space Grotesk", "Gill Sans", "Trebuchet MS", sans-serif;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    .hud {
      position: absolute;
      left: 20px;
      top: 18px;
      padding: 14px 16px;
      background: rgba(10, 15, 20, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      box-shadow: 0 18px 40px rgba(10, 15, 20, 0.45);
      backdrop-filter: blur(10px);
      max-width: 320px;
    }

    .hud h1 {
      margin: 0 0 6px 0;
      font-family: "Bebas Neue", "Impact", sans-serif;
      font-size: 28px;
      letter-spacing: 1px;
      color: #fff3df;
    }

    .hud .stats {
      display: grid;
      grid-template-columns: auto auto;
      gap: 6px 14px;
      font-size: 14px;
    }

    .hud .stats span {
      color: #f6c18b;
      font-weight: 600;
    }

    .hud .tipline {
      margin-top: 8px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.75);
    }

    .banner {
      position: absolute;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%);
      padding: 12px 18px;
      border-radius: 999px;
      background: rgba(10, 15, 20, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.15);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      box-shadow: 0 0 25px rgba(246, 90, 75, 0.35);
      animation: pulse 2.4s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); box-shadow: 0 0 25px rgba(246, 90, 75, 0.3); }
      50% { transform: translateX(-50%) scale(1.04); box-shadow: 0 0 40px rgba(246, 90, 75, 0.6); }
    }

    .meter {
      position: absolute;
      right: 20px;
      top: 18px;
      padding: 10px 14px;
      border-radius: 14px;
      background: rgba(10, 15, 20, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 13px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 140px;
    }

    .meter .label {
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 1.4px;
      color: rgba(255, 255, 255, 0.65);
    }

    .meter .value {
      font-size: 18px;
      font-weight: 700;
      color: #fff1d8;
    }

    .meter .power {
      font-size: 12px;
      color: #6fe2c8;
      min-height: 16px;
    }

    .gameover {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(8, 12, 16, 0.68);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    .gameover.show {
      opacity: 1;
      pointer-events: auto;
    }

    .card {
      background: rgba(12, 18, 24, 0.92);
      border-radius: 18px;
      padding: 22px 26px;
      width: min(420px, 90vw);
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 26px 60px rgba(8, 12, 16, 0.6);
    }

    .card h2 {
      margin: 0 0 8px;
      font-family: "Bebas Neue", "Impact", sans-serif;
      font-size: 34px;
      color: #ffb07a;
      letter-spacing: 1.2px;
    }

    .card p {
      margin: 0 0 14px;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.82);
    }

    .card button {
      border: none;
      border-radius: 999px;
      padding: 10px 20px;
      font-family: "Space Grotesk", sans-serif;
      font-weight: 700;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      background: linear-gradient(120deg, #f65a4b, #f1b84c);
      color: #20130d;
      cursor: pointer;
    }

    .card button:active { transform: translateY(1px); }

    .legend {
      position: absolute;
      left: 20px;
      bottom: 18px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.72);
    }

    .legend span {
      background: rgba(255, 255, 255, 0.12);
      padding: 2px 6px;
      border-radius: 6px;
      margin: 0 2px;
      display: inline-block;
    }

    .touch-controls {
      position: absolute;
      left: 50%;
      bottom: 70px;
      transform: translateX(-50%);
      display: none;
      gap: 16px;
      pointer-events: auto;
    }

    .touch-btn {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(10, 15, 20, 0.55);
      color: #fff1d8;
      font-size: 28px;
      display: grid;
      place-items: center;
      box-shadow: 0 12px 28px rgba(10, 15, 20, 0.4);
      user-select: none;
      touch-action: manipulation;
    }

    .touch-btn:active {
      transform: scale(0.96);
      background: rgba(246, 90, 75, 0.5);
    }

    @media (max-width: 720px) {
      .hud { left: 12px; top: 10px; }
      .meter { right: 12px; top: 10px; }
      .legend { left: 12px; bottom: 12px; }
      .banner { font-size: 12px; }
    }

    @media (hover: none) and (pointer: coarse) {
      .touch-controls { display: flex; }
      .legend { display: none; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="ui">
    <div class="hud">
      <h1>Saigon Street Sprint</h1>
      <div class="stats">
        <div>Distance</div><span id="distance">0</span>
        <div>Score</div><span id="score">0</span>
      </div>
      <div class="tipline">Weave lanes like a local. Avoid sudden merges.</div>
    </div>
    <div class="meter">
      <div class="label">Speed</div>
      <div class="value" id="speed">0 km/h</div>
      <div class="power" id="power">&nbsp;</div>
    </div>
    <div class="banner" id="banner">Tap or press Space to ride</div>
    <div class="legend">Switch lanes: <span>A</span><span>D</span> or <span>Left</span><span>Right</span> | Powerups: <span>Glow</span></div>
    <div class="touch-controls" id="touchControls">
      <button class="touch-btn" id="leftBtn" aria-label="Move left">◀</button>
      <button class="touch-btn" id="rightBtn" aria-label="Move right">▶</button>
    </div>
    <div class="gameover" id="gameover">
      <div class="card">
        <h2>Wipeout</h2>
        <p id="tip">Tip: Keep distance from parked buses. They hide door swings.</p>
        <button id="restart">Ride again</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const distanceEl = document.getElementById('distance');
      const scoreEl = document.getElementById('score');
      const speedEl = document.getElementById('speed');
      const powerEl = document.getElementById('power');
      const bannerEl = document.getElementById('banner');
      const gameoverEl = document.getElementById('gameover');
      const tipEl = document.getElementById('tip');
      const restartBtn = document.getElementById('restart');
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');

      let W = 0, H = 0, DPR = 1;
      let skyline = [];

      const rand = (a, b) => a + Math.random() * (b - a);
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;

      const road = {
        maxZ: 900,
        nearY: 0,
        farY: 0,
        nearHalf: 0,
        farHalf: 0,
        laneFactor: 0.56
      };

      const state = {
        mode: 'ready',
        speed: 240,
        distance: 0,
        score: 0,
        bonusScore: 0,
        multiplier: 1,
        multiplierTimer: 0,
        lane: 0,
        targetLane: 0,
        laneVelocity: 0,
        spawnTimer: 0.8,
        obstacles: [],
        powerups: [],
        lastTip: 'Tip: Keep distance from parked buses. They hide door swings.',
        time: 0
      };

      const tips = {
        static: 'Tip: Glide early into the open lane. Static hazards stay put.',
        long: 'Tip: Long barricades demand a full lane change. Commit early.',
        crossing: 'Tip: Watch for crossing scooters. Slow lane changes beat panic swerves.',
        switcher: 'Tip: If a bike signals, assume it will merge. Leave them space.'
      };

      const powerupTypes = [
        { name: 'coffee', label: 'Ca phe boost', color: '#6fe2c8' },
        { name: 'pho', label: 'Pho focus', color: '#f1b84c' },
        { name: 'lotus', label: 'Lotus calm', color: '#f65a4b' }
      ];

      function resize() {
        DPR = Math.min(window.devicePixelRatio || 1, 2);
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = W * DPR;
        canvas.height = H * DPR;
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        road.nearY = H * 0.92;
        road.farY = H * 0.25;
        road.nearHalf = W * 0.38;
        road.farHalf = W * 0.08;
        buildSkyline();
      }

      function buildSkyline() {
        skyline = [];
        let x = -60;
        while (x < W + 80) {
          const w = rand(40, 120);
          const h = rand(60, 220);
          skyline.push({ x, w, h });
          x += w + rand(20, 50);
        }
      }

      function project(laneValue, z, curveShift) {
        const t = clamp(z / road.maxZ, 0, 1);
        const y = lerp(road.nearY, road.farY, t);
        const half = lerp(road.nearHalf, road.farHalf, t);
        const x = W / 2 + curveShift + laneValue * half * road.laneFactor;
        const scale = lerp(1, 0.18, t);
        return { x, y, scale, half };
      }

      function roundRectPath(x, y, w, h, r) {
        const radius = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + w, y, x + w, y + h, radius);
        ctx.arcTo(x + w, y + h, x, y + h, radius);
        ctx.arcTo(x, y + h, x, y, radius);
        ctx.arcTo(x, y, x + w, y, radius);
        ctx.closePath();
      }

      function startGame() {
        state.mode = 'running';
        state.distance = 0;
        state.score = 0;
        state.bonusScore = 0;
        state.multiplier = 1;
        state.multiplierTimer = 0;
        state.lane = 0;
        state.targetLane = 0;
        state.laneVelocity = 0;
        state.obstacles = [];
        state.powerups = [];
        state.spawnTimer = 0.7;
        bannerEl.style.display = 'none';
        gameoverEl.classList.remove('show');
      }

      function gameOver(reason) {
        state.mode = 'over';
        state.lastTip = tips[reason] || state.lastTip;
        tipEl.textContent = state.lastTip;
        gameoverEl.classList.add('show');
        bannerEl.style.display = 'block';
        bannerEl.textContent = 'Tap or press Space to ride again';
      }

      function handleInput(dir) {
        if (state.mode === 'ready') {
          startGame();
          return;
        }
        if (state.mode === 'over') {
          startGame();
          return;
        }
        state.targetLane = clamp(state.targetLane + dir, -1, 1);
      }

      function spawnObstacle() {
        const r = Math.random();
        if (r < 0.45) {
          const isLong = Math.random() < 0.3;
          state.obstacles.push({
            kind: isLong ? 'long' : 'static',
            lane: [-1, 0, 1][Math.floor(rand(0, 3))],
            z: road.maxZ + rand(80, 180),
            length: isLong ? rand(160, 260) : 0,
            seed: Math.random()
          });
        } else if (r < 0.7) {
          const dir = Math.random() < 0.5 ? -1 : 1;
          state.obstacles.push({
            kind: 'crossing',
            z: road.maxZ + rand(80, 160),
            cross: dir === -1 ? 1 : 0,
            dir,
            speed: rand(0.35, 0.55),
            seed: Math.random()
          });
        } else {
          const lane = [-1, 0, 1][Math.floor(rand(0, 3))];
          let target = lane + (Math.random() < 0.5 ? -1 : 1);
          if (target < -1 || target > 1) target = -target;
          state.obstacles.push({
            kind: 'switcher',
            lane,
            target,
            z: road.maxZ + rand(80, 160),
            switchAt: rand(260, 420),
            switchProgress: 0,
            switchDuration: rand(0.6, 1.1),
            seed: Math.random()
          });
        }

        if (Math.random() < 0.35) {
          const p = powerupTypes[Math.floor(rand(0, powerupTypes.length))];
          state.powerups.push({
            kind: 'power',
            lane: [-1, 0, 1][Math.floor(rand(0, 3))],
            z: road.maxZ + rand(60, 140),
            type: p,
            bob: rand(0, Math.PI * 2)
          });
        }
      }

      function update(dt) {
        state.time += dt;
        if (state.mode !== 'running') return;

        state.distance += state.speed * dt;
        state.spawnTimer -= dt;
        if (state.spawnTimer <= 0) {
          spawnObstacle();
          state.spawnTimer = rand(0.55, 1.1);
        }

        const laneEase = 1 - Math.exp(-dt * 12);
        state.lane = lerp(state.lane, state.targetLane, laneEase);

        if (state.multiplierTimer > 0) {
          state.multiplierTimer -= dt;
          if (state.multiplierTimer <= 0) {
            state.multiplier = 1;
            powerEl.textContent = '';
          }
        }

        const speedFactor = 1 + Math.min(state.distance / 2800, 0.45);
        const travel = state.speed * speedFactor * dt;

        for (const obs of state.obstacles) {
          obs.z -= travel;
          if (obs.kind === 'crossing') {
            obs.cross = clamp(obs.cross + obs.speed * dt * obs.dir, 0, 1);
          }
          if (obs.kind === 'switcher' && obs.z < obs.switchAt) {
            obs.switchProgress = clamp(obs.switchProgress + dt / obs.switchDuration, 0, 1);
          }
        }

        for (const pow of state.powerups) {
          pow.z -= travel;
          pow.bob += dt * 4;
        }

        const collisionZ = 24;
        const despawnZ = -40;
        const remaining = [];
        for (const obs of state.obstacles) {
          const laneValue = getObstacleLane(obs);
          const laneHit = Math.abs(state.lane - laneValue) < 0.35;
          if (obs.kind === 'long') {
            if (laneHit && obs.z < collisionZ && obs.z > -obs.length) {
              gameOver('long');
            }
          } else if (obs.z < collisionZ && obs.z > -12 && laneHit) {
            gameOver(obs.kind);
          }

          if (obs.z > despawnZ) remaining.push(obs);
        }
        state.obstacles = remaining;

        const remainingPower = [];
        for (const pow of state.powerups) {
          const laneHit = Math.abs(state.lane - pow.lane) < 0.35;
          if (pow.z < 26 && pow.z > -12 && laneHit) {
            state.multiplier = 2;
            state.multiplierTimer = 4.2;
            state.bonusScore += 150;
            powerEl.textContent = pow.type.label + ' x2';
          } else if (pow.z > despawnZ) {
            remainingPower.push(pow);
          }
        }
        state.powerups = remainingPower;

        state.score = Math.floor(state.distance * 0.6 * state.multiplier + state.bonusScore);
        updateHUD(speedFactor);
      }

      function updateHUD(speedFactor) {
        distanceEl.textContent = Math.floor(state.distance) + ' m';
        scoreEl.textContent = state.score;
        speedEl.textContent = Math.floor(state.speed * speedFactor * 0.24) + ' km/h';
      }

      function getObstacleLane(obs) {
        if (obs.kind === 'crossing') {
          const start = obs.dir === 1 ? -1.4 : 1.4;
          const end = obs.dir === 1 ? 1.4 : -1.4;
          return lerp(start, end, obs.cross);
        }
        if (obs.kind === 'switcher') {
          return lerp(obs.lane, obs.target, easeInOut(obs.switchProgress));
        }
        return obs.lane;
      }

      function easeInOut(t) {
        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      }

      function draw() {
        ctx.clearRect(0, 0, W, H);
        drawSky();
        const curveShift = Math.sin(state.distance / 420) * W * 0.03;
        drawRoad(curveShift);
        drawObjects(curveShift);
        drawPlayer(curveShift);
      }

      function drawSky() {
        const grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0, '#f8b18a');
        grad.addColorStop(0.45, '#9dd7ff');
        grad.addColorStop(1, '#2c3f6d');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = 'rgba(255, 214, 155, 0.85)';
        ctx.beginPath();
        ctx.arc(W * 0.12, H * 0.16, 48, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#182438';
        for (const b of skyline) {
          ctx.fillRect(b.x, road.farY + 20 - b.h, b.w, b.h + 60);
        }

        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        for (let i = 0; i < 6; i++) {
          const x = (i / 6) * W + (state.time * 18) % W;
          ctx.fillRect(x - 30, H * 0.18 + (i % 2) * 20, 120, 8);
        }
      }

      function drawRoad(curveShift) {
        const leftNear = W / 2 - road.nearHalf + curveShift;
        const rightNear = W / 2 + road.nearHalf + curveShift;
        const leftFar = W / 2 - road.farHalf + curveShift;
        const rightFar = W / 2 + road.farHalf + curveShift;

        ctx.fillStyle = '#161d24';
        ctx.beginPath();
        ctx.moveTo(leftNear, road.nearY);
        ctx.lineTo(leftFar, road.farY);
        ctx.lineTo(rightFar, road.farY);
        ctx.lineTo(rightNear, road.nearY);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = 'rgba(255, 210, 138, 0.35)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(leftNear, road.nearY);
        ctx.lineTo(leftFar, road.farY);
        ctx.moveTo(rightNear, road.nearY);
        ctx.lineTo(rightFar, road.farY);
        ctx.stroke();

        const lanes = [-0.5, 0.5];
        for (const lane of lanes) {
          for (let i = 0; i < 18; i++) {
            const z1 = (i / 18) * road.maxZ;
            const z2 = z1 + 22;
            const p1 = project(lane, z1, curveShift);
            const p2 = project(lane, z2, curveShift);
            ctx.strokeStyle = 'rgba(255, 221, 170, 0.45)';
            ctx.lineWidth = Math.max(1, 2.4 * p1.scale);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        }
      }

      function drawObjects(curveShift) {
        const all = [];
        for (const obs of state.obstacles) all.push({ z: obs.z, obj: obs });
        for (const pow of state.powerups) all.push({ z: pow.z, obj: pow });
        all.sort((a, b) => b.z - a.z);

        for (const item of all) {
          const obj = item.obj;
          if (item.z < 8) continue;
          if (obj.kind === 'power') {
            drawPowerup(obj, curveShift);
          } else if (obj.kind === 'long') {
            drawLongObstacle(obj, curveShift);
          } else {
            drawObstacle(obj, curveShift);
          }
        }
      }

      function drawObstacle(obs, curveShift) {
        const laneValue = getObstacleLane(obs);
        const p = project(laneValue, obs.z, curveShift);
        const width = 42 * p.scale;
        const height = 60 * p.scale;

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.fillStyle = obs.kind === 'switcher' ? '#f1b84c' : '#f65a4b';
        if (obs.kind === 'crossing') {
          ctx.fillStyle = '#6fe2c8';
        }
        roundRectPath(-width * 0.55, -height, width * 1.1, height, 6 * p.scale);
        ctx.fill();

        ctx.fillStyle = '#1b232c';
        roundRectPath(-width * 0.4, -height * 0.55, width * 0.8, height * 0.45, 6 * p.scale);
        ctx.fill();

        if (obs.kind === 'switcher' && obs.switchProgress > 0 && obs.switchProgress < 1) {
          const blink = Math.sin(state.time * 12) > 0 ? '#ffd977' : 'rgba(255, 217, 119, 0.3)';
          ctx.fillStyle = blink;
          ctx.fillRect(width * 0.4, -height * 0.7, width * 0.2, height * 0.18);
        }
        ctx.restore();
      }

      function drawLongObstacle(obs, curveShift) {
        const laneValue = obs.lane;
        const p1 = project(laneValue, obs.z, curveShift);
        const p2 = project(laneValue, obs.z + obs.length, curveShift);
        const width1 = 60 * p1.scale;
        const width2 = 60 * p2.scale;

        ctx.fillStyle = '#f65a4b';
        ctx.beginPath();
        ctx.moveTo(p1.x - width1, p1.y);
        ctx.lineTo(p2.x - width2, p2.y);
        ctx.lineTo(p2.x + width2, p2.y);
        ctx.lineTo(p1.x + width1, p1.y);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = 'rgba(0,0,0,0.25)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p1.x - width1 * 0.4, p1.y);
        ctx.lineTo(p2.x - width2 * 0.4, p2.y);
        ctx.stroke();
      }

      function drawPowerup(pow, curveShift) {
        const p = project(pow.lane, pow.z, curveShift);
        const r = 18 * p.scale * (1 + Math.sin(pow.bob) * 0.08);
        ctx.save();
        ctx.translate(p.x, p.y - 24 * p.scale);
        ctx.fillStyle = pow.type.color;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.lineWidth = 2 * p.scale;
        ctx.beginPath();
        ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      function drawPlayer(curveShift) {
        const p = project(state.lane, 0, curveShift);
        const width = 70;
        const height = 120;
        const bob = Math.sin(state.time * 8) * 3;

        ctx.save();
        ctx.translate(p.x, p.y + bob);

        ctx.fillStyle = '#1b232c';
        roundRectPath(-width * 0.35, -height * 0.55, width * 0.7, height * 0.6, 12);
        ctx.fill();

        ctx.fillStyle = '#f1b84c';
        roundRectPath(-width * 0.28, -height * 0.95, width * 0.56, height * 0.4, 12);
        ctx.fill();

        ctx.fillStyle = '#0b1218';
        ctx.fillRect(-width * 0.4, -height * 0.1, width * 0.8, height * 0.2);

        ctx.fillStyle = '#f65a4b';
        ctx.beginPath();
        ctx.arc(-width * 0.3, 0, 12, 0, Math.PI * 2);
        ctx.arc(width * 0.3, 0, 12, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#fff1d8';
        ctx.beginPath();
        ctx.arc(0, -height * 0.65, 12, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function loop(ts) {
        if (!state.last) state.last = ts;
        const dt = Math.min((ts - state.last) / 1000, 0.033);
        state.last = ts;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      window.addEventListener('resize', resize);
      window.addEventListener('keydown', (e) => {
        if (e.code === 'ArrowLeft' || e.code === 'KeyA') handleInput(-1);
        if (e.code === 'ArrowRight' || e.code === 'KeyD') handleInput(1);
        if (e.code === 'Space') handleInput(0);
      });

      leftBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        handleInput(-1);
      });
      rightBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        handleInput(1);
      });

      let touchStart = null;
      window.addEventListener('pointerdown', (e) => {
        touchStart = { x: e.clientX, y: e.clientY };
      });
      window.addEventListener('pointerup', (e) => {
        if (!touchStart) return;
        const dx = e.clientX - touchStart.x;
        const dy = e.clientY - touchStart.y;
        if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {
          handleInput(dx > 0 ? 1 : -1);
        } else if (state.mode !== 'running') {
          handleInput(0);
        }
        touchStart = null;
      });

      restartBtn.addEventListener('click', () => startGame());

      resize();
      updateHUD(1);
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
