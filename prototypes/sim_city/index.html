<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Saigon Street Sprint</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Space+Grotesk:wght@400;600;700&display=swap');

    :root {
      --ink: #0a0f14;
      --road: #1b232c;
      --lane: rgba(255, 230, 184, 0.7);
      --edge: rgba(255, 213, 120, 0.5);
      --accent: #f65a4b;
      --accent-2: #f1b84c;
      --mint: #6fe2c8;
      --sky-1: #f8b18a;
      --sky-2: #9dd7ff;
      --glow: rgba(255, 184, 120, 0.3);
    }

    * { box-sizing: border-box; }

    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at 10% 10%, #ffe5d0, #a0d9ff 45%, #5671b6 100%);
      color: #f6f1ea;
      font-family: "Space Grotesk", "Gill Sans", "Trebuchet MS", sans-serif;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .ui {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    .hud {
      position: absolute;
      left: 20px;
      top: 18px;
      padding: 14px 16px;
      background: rgba(10, 15, 20, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 14px;
      box-shadow: 0 18px 40px rgba(10, 15, 20, 0.45);
      backdrop-filter: blur(10px);
      max-width: 320px;
    }

    .hud h1 {
      margin: 0 0 6px 0;
      font-family: "Bebas Neue", "Impact", sans-serif;
      font-size: 28px;
      letter-spacing: 1px;
      color: #fff3df;
    }

    .hud .stats {
      display: grid;
      grid-template-columns: auto auto;
      gap: 6px 14px;
      font-size: 14px;
    }

    .hud .stats span {
      color: #f6c18b;
      font-weight: 600;
    }

    .hud .tipline {
      margin-top: 8px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.75);
    }

    .banner {
      position: absolute;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%);
      padding: 12px 18px;
      border-radius: 999px;
      background: rgba(10, 15, 20, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.15);
      font-size: 14px;
      text-transform: uppercase;
      letter-spacing: 1.2px;
      box-shadow: 0 0 25px rgba(246, 90, 75, 0.35);
      animation: pulse 2.4s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: translateX(-50%) scale(1); box-shadow: 0 0 25px rgba(246, 90, 75, 0.3); }
      50% { transform: translateX(-50%) scale(1.04); box-shadow: 0 0 40px rgba(246, 90, 75, 0.6); }
    }

    .meter {
      position: absolute;
      right: 20px;
      top: 18px;
      padding: 10px 14px;
      border-radius: 14px;
      background: rgba(10, 15, 20, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.12);
      font-size: 13px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 140px;
    }

    .meter .label {
      text-transform: uppercase;
      font-size: 11px;
      letter-spacing: 1.4px;
      color: rgba(255, 255, 255, 0.65);
    }

    .meter .value {
      font-size: 18px;
      font-weight: 700;
      color: #fff1d8;
    }

    .meter .power {
      font-size: 12px;
      color: #6fe2c8;
      min-height: 16px;
    }

    .gameover {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(8, 12, 16, 0.68);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
    }

    .gameover.show {
      opacity: 1;
      pointer-events: auto;
    }

    .card {
      background: rgba(12, 18, 24, 0.92);
      border-radius: 18px;
      padding: 22px 26px;
      width: min(420px, 90vw);
      text-align: center;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 26px 60px rgba(8, 12, 16, 0.6);
    }

    .card h2 {
      margin: 0 0 8px;
      font-family: "Bebas Neue", "Impact", sans-serif;
      font-size: 34px;
      color: #ffb07a;
      letter-spacing: 1.2px;
    }

    .card p {
      margin: 0 0 14px;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.82);
    }

    .card button {
      border: none;
      border-radius: 999px;
      padding: 10px 20px;
      font-family: "Space Grotesk", sans-serif;
      font-weight: 700;
      letter-spacing: 0.8px;
      text-transform: uppercase;
      background: linear-gradient(120deg, #f65a4b, #f1b84c);
      color: #20130d;
      cursor: pointer;
    }

    .card button:active { transform: translateY(1px); }

    .legend {
      position: absolute;
      left: 20px;
      bottom: 18px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.72);
    }

    .legend span {
      background: rgba(255, 255, 255, 0.12);
      padding: 2px 6px;
      border-radius: 6px;
      margin: 0 2px;
      display: inline-block;
    }

    .touch-controls {
      position: absolute;
      left: 50%;
      bottom: 70px;
      transform: translateX(-50%);
      display: none;
      gap: 16px;
      pointer-events: auto;
    }

    .touch-btn {
      width: 64px;
      height: 64px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(10, 15, 20, 0.55);
      color: #fff1d8;
      font-size: 28px;
      display: grid;
      place-items: center;
      box-shadow: 0 12px 28px rgba(10, 15, 20, 0.4);
      user-select: none;
      touch-action: manipulation;
    }

    .touch-btn:active {
      transform: scale(0.96);
      background: rgba(246, 90, 75, 0.5);
    }

    @media (max-width: 720px) {
      .hud { left: 12px; top: 10px; }
      .meter { right: 12px; top: 10px; }
      .legend { left: 12px; bottom: 12px; }
      .banner { font-size: 12px; }
    }

    @media (hover: none) and (pointer: coarse) {
      .touch-controls { display: flex; }
      .legend { display: none; }
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="ui">
    <div class="hud">
      <h1>Saigon Street Sprint</h1>
      <div class="stats">
        <div>Distance</div><span id="distance">0</span>
        <div>Score</div><span id="score">0</span>
        <div>Top score</div><span id="highscore">0</span>
      </div>
      <div class="tipline">Weave lanes like a local. Avoid sudden merges.</div>
    </div>
    <div class="meter">
      <div class="label">Speed</div>
      <div class="value" id="speed">0 km/h</div>
      <div class="power" id="power">&nbsp;</div>
    </div>
    <div class="banner" id="banner">Tap or press Space to ride</div>
    <div class="legend">Switch lanes: <span>A</span><span>D</span> or <span>Left</span><span>Right</span> | Powerups: <span>Glow</span></div>
    <div class="touch-controls" id="touchControls">
      <button class="touch-btn" id="leftBtn" aria-label="Move left">◀</button>
      <button class="touch-btn" id="rightBtn" aria-label="Move right">▶</button>
    </div>
    <div class="gameover" id="gameover">
      <div class="card">
        <h2>Wipeout</h2>
        <p id="tip">Tip: Keep distance from parked buses. They hide door swings.</p>
        <button id="restart">Ride again</button>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const distanceEl = document.getElementById('distance');
      const scoreEl = document.getElementById('score');
      const highScoreEl = document.getElementById('highscore');
      const speedEl = document.getElementById('speed');
      const powerEl = document.getElementById('power');
      const bannerEl = document.getElementById('banner');
      const gameoverEl = document.getElementById('gameover');
      const tipEl = document.getElementById('tip');
      const restartBtn = document.getElementById('restart');
      const leftBtn = document.getElementById('leftBtn');
      const rightBtn = document.getElementById('rightBtn');

      let W = 0, H = 0, DPR = 1;
      let skyline = [];

      const rand = (a, b) => a + Math.random() * (b - a);
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const lerp = (a, b, t) => a + (b - a) * t;

      const road = {
        maxZ: 900,
        nearY: 0,
        farY: 0,
        nearHalf: 0,
        farHalf: 0,
        laneFactor: 0.56
      };

      const HI_SCORE_KEY = 'saigon_street_sprint_hi_score';

      const state = {
        mode: 'ready',
        speed: 190,
        distance: 0,
        score: 0,
        highScore: 0,
        bonusScore: 0,
        multiplier: 1,
        multiplierTimer: 0,
        lane: 0,
        targetLane: 0,
        laneVelocity: 0,
        spawnTimer: 1.6,
        obstacles: [],
        powerups: [],
        lastTip: 'Tip: Keep distance from parked buses. They hide door swings.',
        time: 0
      };

      const tips = {
        static: 'Tip: Glide early into the open lane. Static hazards stay put.',
        dividerLong: 'Tip: Divider barriers stay in the middle. Clear center lane early.',
        constructionLong: 'Tip: Long roadwork blocks one lane for a while. Commit to another lane.',
        crossingFast: 'Tip: Fast crossers are small but sudden. Predict, do not react late.',
        crossingHeavy: 'Tip: Big crossers move slower but occupy more width. Give them a full lane.',
        switcher: 'Tip: If a bike signals, assume it will merge. Leave it space before the switch.'
      };

      const laneChoices = [-1, 0, 1];
      const imageCache = new Map();

      // Asset placeholders by mechanic.
      // Replace placeholder art by setting image, e.g. image: 'assets/obstacles/scooter.png'.
      // Keep width/height tuned to your sprite proportions for correct perspective/collision feel.
      // To reuse mechanics with multiple visuals, add more keys in obstacleMechanics.*.assets.
      const obstacleAssets = {
        parkedScooter: { template: 'bike', width: 46, height: 62, body: '#f65a4b', trim: '#1b232c', detail: '#ffd977', label: 'Scooter', image: '' },
        plasticCrate: { template: 'crate', width: 42, height: 56, body: '#ef7249', trim: '#1b232c', detail: '#ffd977', label: 'Crate', image: '' },
        streetBin: { template: 'bin', width: 44, height: 64, body: '#5aa0d5', trim: '#1b232c', detail: '#dff2ff', label: 'Bin', image: '' },
        medianBlocks: { template: 'divider', body: '#f3c056', trim: '#25313f', detail: '#fff5d9', label: 'Divider', image: '' },
        medianFence: { template: 'dividerAlt', body: '#f7a94c', trim: '#25313f', detail: '#fff5d9', label: 'Fence', image: '' },
        constructionBarrier: { template: 'construction', body: '#f65a4b', trim: '#ffd68f', detail: '#1f2a34', label: 'Roadwork', image: '' },
        pipeStack: { template: 'constructionAlt', body: '#f18d4b', trim: '#21303c', detail: '#f9d8a7', label: 'Pipes', image: '' },
        fastBike: { template: 'crosserFast', width: 40, height: 52, body: '#6fe2c8', trim: '#1b232c', detail: '#d5fff6', label: 'Bike', image: '' },
        strayDog: { template: 'crosserFastAlt', width: 38, height: 48, body: '#8ed38a', trim: '#21322b', detail: '#f2ffe9', label: 'Dog', image: '' },
        deliveryCart: { template: 'crosserHeavy', width: 68, height: 72, body: '#57a0d4', trim: '#1b232c', detail: '#e7f6ff', label: 'Cart', image: '' },
        miniTruck: { template: 'crosserHeavyAlt', width: 76, height: 78, body: '#f1b84c', trim: '#1b232c', detail: '#fff4cc', label: 'Truck', image: '' },
        commuterBike: { template: 'switcherBike', width: 44, height: 60, body: '#f1b84c', trim: '#1b232c', detail: '#ffe7af', label: 'Bike', image: '' },
        taxiBike: { template: 'switcherBike', width: 46, height: 62, body: '#ffc75b', trim: '#1b232c', detail: '#fff2ca', label: 'Taxi', image: '' },
        deliveryBike: { template: 'switcherBike', width: 44, height: 60, body: '#f08f4d', trim: '#1b232c', detail: '#ffe5c2', label: 'Delivery', image: '' },
        fallback: { template: 'crate', width: 44, height: 60, body: '#f65a4b', trim: '#1b232c', detail: '#ffe2bd', label: 'Obstacle', image: '' }
      };

      // Each mechanic controls behavior; the assets list controls which visuals can spawn for that behavior.
      const obstacleMechanics = {
        static: {
          kind: 'static',
          weight: 30,
          tipKey: 'static',
          spawnZ: [80, 180],
          laneRule: 'any',
          hitWidth: 0.33,
          assets: ['parkedScooter', 'plasticCrate', 'streetBin']
        },
        dividerLong: {
          kind: 'long',
          variant: 'divider',
          weight: 14,
          tipKey: 'dividerLong',
          spawnZ: [90, 180],
          laneRule: 'center',
          hitWidth: 0.27,
          length: [240, 340],
          assets: ['medianBlocks', 'medianFence']
        },
        constructionLong: {
          kind: 'long',
          variant: 'construction',
          weight: 16,
          tipKey: 'constructionLong',
          spawnZ: [80, 170],
          laneRule: 'any',
          hitWidth: 0.36,
          length: [170, 260],
          assets: ['constructionBarrier', 'pipeStack']
        },
        crossingFast: {
          kind: 'crossing',
          variant: 'fast',
          weight: 14,
          tipKey: 'crossingFast',
          spawnZ: [80, 160],
          speed: [0.72, 1.0],
          hitWidth: 0.24,
          startSpread: 1.52,
          assets: ['fastBike', 'strayDog']
        },
        crossingHeavy: {
          kind: 'crossing',
          variant: 'heavy',
          weight: 10,
          tipKey: 'crossingHeavy',
          spawnZ: [80, 160],
          speed: [0.24, 0.38],
          hitWidth: 0.44,
          startSpread: 1.44,
          assets: ['deliveryCart', 'miniTruck']
        },
        switcher: {
          kind: 'switcher',
          weight: 16,
          tipKey: 'switcher',
          spawnZ: [80, 170],
          laneRule: 'any',
          hitWidth: 0.33,
          signalStartZ: [250, 390],
          signalDuration: [0.45, 0.9],
          switchDuration: [0.35, 0.65],
          assets: ['commuterBike', 'taxiBike', 'deliveryBike']
        }
      };

      const mechanicWeights = Object.entries(obstacleMechanics).map(([key, cfg]) => ({ key, weight: cfg.weight }));

      const powerupTypes = [
        { name: 'coffee', label: 'Ca phe boost', color: '#6fe2c8' },
        { name: 'pho', label: 'Pho focus', color: '#f1b84c' },
        { name: 'lotus', label: 'Lotus calm', color: '#f65a4b' }
      ];

      function resize() {
        DPR = Math.min(window.devicePixelRatio || 1, 2);
        W = window.innerWidth;
        H = window.innerHeight;
        canvas.width = W * DPR;
        canvas.height = H * DPR;
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        road.nearY = H * 0.92;
        road.farY = H * 0.25;
        road.nearHalf = W * 0.38;
        road.farHalf = W * 0.08;
        buildSkyline();
      }

      function buildSkyline() {
        skyline = [];
        let x = -60;
        while (x < W + 80) {
          const w = rand(40, 120);
          const h = rand(60, 220);
          skyline.push({ x, w, h });
          x += w + rand(20, 50);
        }
      }

      function project(laneValue, z, curveShift) {
        const t = clamp(z / road.maxZ, 0, 1);
        const y = lerp(road.nearY, road.farY, t);
        const half = lerp(road.nearHalf, road.farHalf, t);
        const x = W / 2 + curveShift + laneValue * half * road.laneFactor;
        const scale = lerp(1, 0.18, t);
        return { x, y, scale, half };
      }

      function roundRectPath(x, y, w, h, r) {
        const radius = Math.min(r, w / 2, h / 2);
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.arcTo(x + w, y, x + w, y + h, radius);
        ctx.arcTo(x + w, y + h, x, y + h, radius);
        ctx.arcTo(x, y + h, x, y, radius);
        ctx.arcTo(x, y, x + w, y, radius);
        ctx.closePath();
      }

      function pickOne(list) {
        return list[Math.floor(Math.random() * list.length)];
      }

      function pickWeighted(items) {
        let total = 0;
        for (const item of items) total += item.weight;
        let cursor = Math.random() * total;
        for (const item of items) {
          cursor -= item.weight;
          if (cursor <= 0) return item.key;
        }
        return items[items.length - 1].key;
      }

      function randomLane() {
        return pickOne(laneChoices);
      }

      function randomAdjacentLane(lane) {
        const options = [];
        if (lane > -1) options.push(lane - 1);
        if (lane < 1) options.push(lane + 1);
        return pickOne(options);
      }

      function rangeVal(range) {
        return rand(range[0], range[1]);
      }

      function resolveAsset(assetKey) {
        return obstacleAssets[assetKey] || obstacleAssets.fallback;
      }

      function getAssetImage(asset) {
        if (!asset.image) return null;
        if (!imageCache.has(asset.image)) {
          const img = new Image();
          img.src = asset.image;
          imageCache.set(asset.image, img);
        }
        const cached = imageCache.get(asset.image);
        return cached.complete ? cached : null;
      }

      function drawAssetLabel(asset, w, h, scale) {
        if (!asset.label || scale < 0.35) return;
        ctx.fillStyle = 'rgba(14, 20, 28, 0.78)';
        roundRectPath(-w * 0.28, -h * 0.52, w * 0.56, h * 0.24, 4 * scale);
        ctx.fill();
        ctx.fillStyle = 'rgba(255, 247, 228, 0.95)';
        ctx.font = `${Math.max(8, 11 * scale)}px "Space Grotesk", sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(asset.label, 0, -h * 0.4);
      }

      function drawAssetSprite(asset, width, height, scale, fallbackDraw) {
        const img = getAssetImage(asset);
        if (img) {
          ctx.drawImage(img, -width * 0.5, -height, width, height);
          return;
        }
        fallbackDraw();
        drawAssetLabel(asset, width, height, scale);
      }

      function loadHighScore() {
        try {
          const raw = sessionStorage.getItem(HI_SCORE_KEY);
          const parsed = Number.parseInt(raw || '0', 10);
          return Number.isFinite(parsed) ? Math.max(0, parsed) : 0;
        } catch (_) {
          return 0;
        }
      }

      function saveHighScore(value) {
        try {
          sessionStorage.setItem(HI_SCORE_KEY, String(value));
        } catch (_) {
          // Ignore storage errors; game still functions without persistence.
        }
      }

      function getDifficultyProfile(distance) {
        const progress = clamp(distance / 3600, 0, 1);
        return {
          progress,
          spawnMin: lerp(1.38, 0.5, progress),
          spawnMax: lerp(1.95, 0.9, progress),
          speedFactor: lerp(0.84, 1.48, progress),
          overlapGap: lerp(220, 125, progress)
        };
      }

      function mechanicWeightScale(mechanicKey, progress) {
        if (mechanicKey === 'static') return lerp(1.45, 0.85, progress);
        if (mechanicKey === 'dividerLong') return lerp(1.1, 0.9, progress);
        if (mechanicKey === 'constructionLong') return lerp(0.85, 1.1, progress);
        if (mechanicKey === 'crossingFast') return lerp(0.22, 1.25, progress);
        if (mechanicKey === 'crossingHeavy') return lerp(0.15, 1.05, progress);
        if (mechanicKey === 'switcher') return lerp(0.25, 1.35, progress);
        return 1;
      }

      function pickMechanicByDifficulty(profile) {
        const weighted = [];
        for (const item of mechanicWeights) {
          weighted.push({
            key: item.key,
            weight: item.weight * mechanicWeightScale(item.key, profile.progress)
          });
        }
        return pickWeighted(weighted);
      }

      function laneSpanAtSpawn(obstacle) {
        if (obstacle.kind === 'crossing') {
          const spread = obstacle.startSpread || 1.4;
          return { min: -spread, max: spread };
        }
        if (obstacle.kind === 'switcher') {
          const start = Math.min(obstacle.lane, obstacle.target);
          const end = Math.max(obstacle.lane, obstacle.target);
          return { min: start - obstacle.hitWidth, max: end + obstacle.hitWidth };
        }
        return {
          min: obstacle.lane - obstacle.hitWidth,
          max: obstacle.lane + obstacle.hitWidth
        };
      }

      function zSpanAtSpawn(obstacle) {
        if (obstacle.kind === 'long') {
          return {
            min: obstacle.z - 18,
            max: obstacle.z + obstacle.length + 18
          };
        }
        return {
          min: obstacle.z - 24,
          max: obstacle.z + 24
        };
      }

      function spansOverlap(a, b) {
        return !(a.max < b.min || b.max < a.min);
      }

      function zSpansOverlap(a, b, gap) {
        return !(a.max + gap < b.min || b.max + gap < a.min);
      }

      function canPlaceObstacle(candidate, profile) {
        const candidateSpan = laneSpanAtSpawn(candidate);
        const candidateZ = zSpanAtSpawn(candidate);
        const baseGap = profile.overlapGap + (candidate.kind === 'long' ? 55 : 0);
        for (const existing of state.obstacles) {
          if (existing.z < road.maxZ - 250) continue;
          if (candidate.kind === 'long' && existing.kind === 'long' && existing.z > road.maxZ - 180) {
            return false;
          }

          const dynamicGap = baseGap + (existing.kind === 'long' ? 50 : 0) + (existing.kind === 'crossing' || candidate.kind === 'crossing' ? 36 : 0);
          const existingZ = zSpanAtSpawn(existing);
          if (!zSpansOverlap(candidateZ, existingZ, dynamicGap)) continue;

          const existingSpan = laneSpanAtSpawn(existing);
          if (spansOverlap(candidateSpan, existingSpan)) return false;
        }
        return true;
      }

      function startGame() {
        state.mode = 'running';
        state.distance = 0;
        state.score = 0;
        state.bonusScore = 0;
        state.multiplier = 1;
        state.multiplierTimer = 0;
        state.lane = 0;
        state.targetLane = 0;
        state.laneVelocity = 0;
        state.obstacles = [];
        state.powerups = [];
        state.spawnTimer = 1.4;
        bannerEl.style.display = 'none';
        gameoverEl.classList.remove('show');
      }

      function gameOver(reason) {
        state.mode = 'over';
        state.lastTip = tips[reason] || state.lastTip;
        tipEl.textContent = state.lastTip;
        gameoverEl.classList.add('show');
        bannerEl.style.display = 'block';
        bannerEl.textContent = 'Tap or press Space to ride again';
      }

      function handleInput(dir) {
        if (state.mode === 'ready') {
          startGame();
          return;
        }
        if (state.mode === 'over') {
          startGame();
          return;
        }
        state.targetLane = clamp(state.targetLane + dir, -1, 1);
      }

      function spawnObstacle(profile) {
        const mechanicKey = pickMechanicByDifficulty(profile);
        const cfg = obstacleMechanics[mechanicKey];
        const lane = cfg.laneRule === 'center' ? 0 : randomLane();
        const obstacle = {
          mechanicKey,
          kind: cfg.kind,
          tipKey: cfg.tipKey,
          lane,
          z: road.maxZ + rangeVal(cfg.spawnZ),
          hitWidth: cfg.hitWidth,
          assetKey: pickOne(cfg.assets)
        };

        if (cfg.kind === 'long') {
          obstacle.variant = cfg.variant;
          obstacle.length = rangeVal(cfg.length);
        }

        if (cfg.kind === 'crossing') {
          obstacle.variant = cfg.variant;
          obstacle.dir = Math.random() < 0.5 ? -1 : 1;
          obstacle.cross = obstacle.dir === -1 ? 1 : 0;
          obstacle.speed = rangeVal(cfg.speed) * lerp(0.88, 1.08, profile.progress);
          obstacle.startSpread = cfg.startSpread;
        }

        if (cfg.kind === 'switcher') {
          obstacle.target = randomAdjacentLane(lane);
          obstacle.phase = 'signal';
          obstacle.signalStartZ = rangeVal(cfg.signalStartZ) + lerp(22, -28, profile.progress);
          obstacle.signalDuration = rangeVal(cfg.signalDuration) * lerp(1.2, 0.86, profile.progress);
          obstacle.signalElapsed = 0;
          obstacle.switchProgress = 0;
          obstacle.switchDuration = rangeVal(cfg.switchDuration) * lerp(1.15, 0.82, profile.progress);
        }

        if (!canPlaceObstacle(obstacle, profile)) {
          return false;
        }

        state.obstacles.push(obstacle);

        if (Math.random() < 0.35) {
          const p = pickOne(powerupTypes);
          state.powerups.push({
            kind: 'power',
            lane: randomLane(),
            z: road.maxZ + rand(60, 140),
            type: p,
            bob: rand(0, Math.PI * 2)
          });
        }
        return true;
      }

      function update(dt) {
        state.time += dt;
        if (state.mode !== 'running') return;

        const profile = getDifficultyProfile(state.distance);
        const speedFactor = profile.speedFactor;
        const travel = state.speed * speedFactor * dt;
        state.distance += travel;
        state.spawnTimer -= dt;
        if (state.spawnTimer <= 0) {
          let spawned = false;
          for (let i = 0; i < 3 && !spawned; i++) {
            spawned = spawnObstacle(profile);
          }
          state.spawnTimer = rand(profile.spawnMin, profile.spawnMax);
          if (!spawned) state.spawnTimer += 0.25;
        }

        const laneEase = 1 - Math.exp(-dt * 12);
        state.lane = lerp(state.lane, state.targetLane, laneEase);

        if (state.multiplierTimer > 0) {
          state.multiplierTimer -= dt;
          if (state.multiplierTimer <= 0) {
            state.multiplier = 1;
            powerEl.textContent = '';
          }
        }

        for (const obs of state.obstacles) {
          obs.z -= travel;
          if (obs.kind === 'crossing') {
            obs.cross = clamp(obs.cross + obs.speed * dt * obs.dir, 0, 1);
          }
          if (obs.kind === 'switcher') {
            if (obs.phase === 'signal' && obs.z < obs.signalStartZ) {
              obs.signalElapsed += dt;
              if (obs.signalElapsed >= obs.signalDuration) {
                obs.phase = 'switch';
              }
            } else if (obs.phase === 'switch') {
              obs.switchProgress = clamp(obs.switchProgress + dt / obs.switchDuration, 0, 1);
            }
          }
        }

        for (const pow of state.powerups) {
          pow.z -= travel;
          pow.bob += dt * 4;
        }

        const collisionZ = 24;
        const despawnZ = -40;
        const remaining = [];
        for (const obs of state.obstacles) {
          const laneValue = getObstacleLane(obs);
          const laneHit = Math.abs(state.lane - laneValue) < obs.hitWidth;
          if (obs.kind === 'long') {
            if (laneHit && obs.z < collisionZ && obs.z > -obs.length) {
              gameOver(obs.tipKey);
            }
          } else if (obs.z < collisionZ && obs.z > -12 && laneHit) {
            gameOver(obs.tipKey);
          }

          if (obs.z > despawnZ) remaining.push(obs);
        }
        state.obstacles = remaining;

        const remainingPower = [];
        for (const pow of state.powerups) {
          const laneHit = Math.abs(state.lane - pow.lane) < 0.35;
          if (pow.z < 26 && pow.z > -12 && laneHit) {
            state.multiplier = 2;
            state.multiplierTimer = 4.2;
            state.bonusScore += 150;
            powerEl.textContent = pow.type.label + ' x2';
          } else if (pow.z > despawnZ) {
            remainingPower.push(pow);
          }
        }
        state.powerups = remainingPower;

        state.score = Math.floor(state.distance * 0.6 * state.multiplier + state.bonusScore);
        if (state.score > state.highScore) {
          state.highScore = state.score;
          saveHighScore(state.highScore);
        }
        updateHUD(speedFactor);
      }

      function updateHUD(speedFactor) {
        distanceEl.textContent = Math.floor(state.distance) + ' m';
        scoreEl.textContent = state.score;
        highScoreEl.textContent = state.highScore;
        speedEl.textContent = Math.floor(state.speed * speedFactor * 0.24) + ' km/h';
      }

      function getObstacleLane(obs) {
        if (obs.kind === 'crossing') {
          const spread = obs.startSpread || 1.4;
          const start = obs.dir === 1 ? -spread : spread;
          const end = obs.dir === 1 ? spread : -spread;
          return lerp(start, end, obs.cross);
        }
        if (obs.kind === 'switcher') {
          if (obs.phase !== 'switch') return obs.lane;
          return lerp(obs.lane, obs.target, easeInOut(obs.switchProgress));
        }
        return obs.lane;
      }

      function easeInOut(t) {
        return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      }

      function draw() {
        ctx.clearRect(0, 0, W, H);
        drawSky();
        const curveShift = Math.sin(state.distance / 420) * W * 0.03;
        drawRoad(curveShift);
        drawObjects(curveShift);
        drawPlayer(curveShift);
      }

      function drawSky() {
        const grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0, '#f8b18a');
        grad.addColorStop(0.45, '#9dd7ff');
        grad.addColorStop(1, '#2c3f6d');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = 'rgba(255, 214, 155, 0.85)';
        ctx.beginPath();
        ctx.arc(W * 0.12, H * 0.16, 48, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#182438';
        for (const b of skyline) {
          ctx.fillRect(b.x, road.farY + 20 - b.h, b.w, b.h + 60);
        }

        ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
        for (let i = 0; i < 6; i++) {
          const x = (i / 6) * W + (state.time * 18) % W;
          ctx.fillRect(x - 30, H * 0.18 + (i % 2) * 20, 120, 8);
        }
      }

      function drawRoad(curveShift) {
        const leftNear = W / 2 - road.nearHalf + curveShift;
        const rightNear = W / 2 + road.nearHalf + curveShift;
        const leftFar = W / 2 - road.farHalf + curveShift;
        const rightFar = W / 2 + road.farHalf + curveShift;

        ctx.fillStyle = '#161d24';
        ctx.beginPath();
        ctx.moveTo(leftNear, road.nearY);
        ctx.lineTo(leftFar, road.farY);
        ctx.lineTo(rightFar, road.farY);
        ctx.lineTo(rightNear, road.nearY);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = 'rgba(255, 210, 138, 0.35)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(leftNear, road.nearY);
        ctx.lineTo(leftFar, road.farY);
        ctx.moveTo(rightNear, road.nearY);
        ctx.lineTo(rightFar, road.farY);
        ctx.stroke();

        const lanes = [-0.5, 0.5];
        for (const lane of lanes) {
          for (let i = 0; i < 18; i++) {
            const z1 = (i / 18) * road.maxZ;
            const z2 = z1 + 22;
            const p1 = project(lane, z1, curveShift);
            const p2 = project(lane, z2, curveShift);
            ctx.strokeStyle = 'rgba(255, 221, 170, 0.45)';
            ctx.lineWidth = Math.max(1, 2.4 * p1.scale);
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        }
      }

      function drawObjects(curveShift) {
        const all = [];
        for (const obs of state.obstacles) all.push({ z: obs.z, obj: obs });
        for (const pow of state.powerups) all.push({ z: pow.z, obj: pow });
        all.sort((a, b) => b.z - a.z);

        for (const item of all) {
          const obj = item.obj;
          if (item.z < 8) continue;
          if (obj.kind === 'power') {
            drawPowerup(obj, curveShift);
          } else {
            drawObstacleByMechanic(obj, curveShift);
          }
        }
      }

      function drawObstacleByMechanic(obs, curveShift) {
        if (obs.kind === 'long') {
          drawLongObstacle(obs, curveShift);
        } else {
          drawObstacle(obs, curveShift);
        }
      }

      function drawObstacle(obs, curveShift) {
        const laneValue = getObstacleLane(obs);
        const p = project(laneValue, obs.z, curveShift);
        const asset = resolveAsset(obs.assetKey);
        const width = (asset.width || 44) * p.scale * 2;
        const height = (asset.height || 60) * p.scale * 2;

        ctx.save();
        ctx.translate(p.x, p.y);
        drawAssetSprite(asset, width, height, p.scale, () => {
          drawObstaclePlaceholder(asset, width, height, p.scale);
        });

        if (obs.kind === 'switcher' && (obs.phase === 'signal' || obs.switchProgress < 1)) {
          const blinkOn = Math.sin(state.time * 14) > 0;
          const blinkColor = blinkOn ? '#ffd977' : 'rgba(255, 217, 119, 0.25)';
          const side = obs.target > obs.lane ? 1 : -1;
          ctx.fillStyle = blinkColor;
          roundRectPath(side * width * 0.35, -height * 0.72, width * 0.2, height * 0.18, 2 * p.scale);
          ctx.fill();
        }
        ctx.restore();
      }

      function drawLongObstacle(obs, curveShift) {
        const laneValue = obs.lane;
        const asset = resolveAsset(obs.assetKey);
        const image = getAssetImage(asset);

        if (image) {
          for (let z = obs.z; z <= obs.z + obs.length; z += 52) {
            if (z < 8 || z > road.maxZ + 200) continue;
            const p = project(laneValue, z, curveShift);
            const w = (asset.width || 50) * p.scale;
            const h = (asset.height || 46) * p.scale;
            ctx.drawImage(image, p.x - w * 0.5, p.y - h, w, h);
          }
          return;
        }

        const p1 = project(laneValue, obs.z, curveShift);
        const p2 = project(laneValue, obs.z + obs.length, curveShift);
        const nearBase = obs.variant === 'divider' ? 44 : 62;
        const farBase = obs.variant === 'divider' ? 34 : 50;
        const width1 = nearBase * p1.scale;
        const width2 = farBase * p2.scale;

        ctx.fillStyle = asset.body || '#f65a4b';
        ctx.beginPath();
        ctx.moveTo(p1.x - width1, p1.y);
        ctx.lineTo(p2.x - width2, p2.y);
        ctx.lineTo(p2.x + width2, p2.y);
        ctx.lineTo(p1.x + width1, p1.y);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = asset.trim || '#1b232c';
        ctx.lineWidth = 1.8;
        ctx.beginPath();
        ctx.moveTo(p1.x - width1 * 0.45, p1.y);
        ctx.lineTo(p2.x - width2 * 0.45, p2.y);
        ctx.moveTo(p1.x + width1 * 0.45, p1.y);
        ctx.lineTo(p2.x + width2 * 0.45, p2.y);
        ctx.stroke();

        ctx.strokeStyle = asset.detail || 'rgba(255,245,217,0.9)';
        ctx.lineWidth = 1.2;
        for (let z = obs.z + 20; z < obs.z + obs.length; z += 42) {
          const p = project(laneValue, z, curveShift);
          const w = (obs.variant === 'divider' ? 28 : 40) * p.scale;
          ctx.beginPath();
          ctx.moveTo(p.x - w * 0.5, p.y);
          ctx.lineTo(p.x + w * 0.5, p.y);
          ctx.stroke();
        }
      }

      function drawObstaclePlaceholder(asset, width, height, scale) {
        const template = asset.template || 'crate';

        if (template === 'bike' || template === 'switcherBike' || template === 'crosserFast' || template === 'crosserFastAlt') {
          ctx.fillStyle = asset.body;
          roundRectPath(-width * 0.44, -height * 0.7, width * 0.88, height * 0.34, 6 * scale);
          ctx.fill();

          ctx.fillStyle = asset.trim;
          roundRectPath(-width * 0.3, -height * 0.9, width * 0.6, height * 0.18, 4 * scale);
          ctx.fill();

          ctx.fillStyle = asset.trim;
          ctx.beginPath();
          ctx.arc(-width * 0.28, -height * 0.18, height * 0.14, 0, Math.PI * 2);
          ctx.arc(width * 0.28, -height * 0.18, height * 0.14, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = asset.detail;
          ctx.beginPath();
          ctx.arc(0, -height * 0.52, height * 0.08, 0, Math.PI * 2);
          ctx.fill();
          return;
        }

        if (template === 'crosserHeavy' || template === 'crosserHeavyAlt') {
          ctx.fillStyle = asset.body;
          roundRectPath(-width * 0.5, -height * 0.78, width, height * 0.66, 7 * scale);
          ctx.fill();
          ctx.fillStyle = asset.trim;
          roundRectPath(-width * 0.24, -height * 0.94, width * 0.48, height * 0.2, 4 * scale);
          ctx.fill();
          ctx.fillStyle = asset.detail;
          ctx.fillRect(-width * 0.32, -height * 0.56, width * 0.64, height * 0.16);
          return;
        }

        if (template === 'bin') {
          ctx.fillStyle = asset.body;
          roundRectPath(-width * 0.44, -height * 0.94, width * 0.88, height * 0.82, 6 * scale);
          ctx.fill();
          ctx.fillStyle = asset.trim;
          roundRectPath(-width * 0.5, -height, width, height * 0.14, 4 * scale);
          ctx.fill();
          ctx.fillStyle = asset.detail;
          ctx.fillRect(-width * 0.26, -height * 0.7, width * 0.52, height * 0.2);
          return;
        }

        ctx.fillStyle = asset.body;
        roundRectPath(-width * 0.5, -height * 0.9, width, height * 0.78, 6 * scale);
        ctx.fill();
        ctx.strokeStyle = asset.trim;
        ctx.lineWidth = Math.max(1, 2 * scale);
        ctx.beginPath();
        ctx.moveTo(-width * 0.5, -height * 0.55);
        ctx.lineTo(width * 0.5, -height * 0.55);
        ctx.moveTo(-width * 0.1, -height * 0.9);
        ctx.lineTo(-width * 0.1, -height * 0.12);
        ctx.stroke();
        ctx.fillStyle = asset.detail;
        ctx.fillRect(width * 0.26, -height * 0.46, width * 0.14, height * 0.14);
      }

      function drawPowerup(pow, curveShift) {
        const p = project(pow.lane, pow.z, curveShift);
        const r = 18 * p.scale * (1 + Math.sin(pow.bob) * 0.08);
        ctx.save();
        ctx.translate(p.x, p.y - 24 * p.scale);
        ctx.fillStyle = pow.type.color;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.8)';
        ctx.lineWidth = 2 * p.scale;
        ctx.beginPath();
        ctx.arc(0, 0, r * 0.6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      function drawPlayer(curveShift) {
        const p = project(state.lane, 0, curveShift);
        const width = 70;
        const height = 120;
        const bob = Math.sin(state.time * 8) * 3;

        ctx.save();
        ctx.translate(p.x, p.y + bob);

        ctx.fillStyle = '#1b232c';
        roundRectPath(-width * 0.35, -height * 0.55, width * 0.7, height * 0.6, 12);
        ctx.fill();

        ctx.fillStyle = '#f1b84c';
        roundRectPath(-width * 0.28, -height * 0.95, width * 0.56, height * 0.4, 12);
        ctx.fill();

        ctx.fillStyle = '#0b1218';
        ctx.fillRect(-width * 0.4, -height * 0.1, width * 0.8, height * 0.2);

        ctx.fillStyle = '#f65a4b';
        ctx.beginPath();
        ctx.arc(-width * 0.3, 0, 12, 0, Math.PI * 2);
        ctx.arc(width * 0.3, 0, 12, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = '#fff1d8';
        ctx.beginPath();
        ctx.arc(0, -height * 0.65, 12, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();
      }

      function loop(ts) {
        if (!state.last) state.last = ts;
        const dt = Math.min((ts - state.last) / 1000, 0.033);
        state.last = ts;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      window.addEventListener('resize', resize);
      window.addEventListener('keydown', (e) => {
        if (e.code === 'ArrowLeft' || e.code === 'KeyA') handleInput(-1);
        if (e.code === 'ArrowRight' || e.code === 'KeyD') handleInput(1);
        if (e.code === 'Space') handleInput(0);
      });

      leftBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        handleInput(-1);
      });
      rightBtn.addEventListener('pointerdown', (e) => {
        e.preventDefault();
        handleInput(1);
      });

      let touchStart = null;
      window.addEventListener('pointerdown', (e) => {
        touchStart = { x: e.clientX, y: e.clientY };
      });
      window.addEventListener('pointerup', (e) => {
        if (!touchStart) return;
        const dx = e.clientX - touchStart.x;
        const dy = e.clientY - touchStart.y;
        if (Math.abs(dx) > 40 && Math.abs(dx) > Math.abs(dy)) {
          handleInput(dx > 0 ? 1 : -1);
        } else if (state.mode !== 'running') {
          handleInput(0);
        }
        touchStart = null;
      });

      restartBtn.addEventListener('click', () => startGame());

      state.highScore = loadHighScore();
      resize();
      updateHUD(1);
      requestAnimationFrame(loop);
    })();
  </script>
</body>
</html>
